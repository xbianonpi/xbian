##
##      Copyright (C) 2012 - 2014 XBian
##
##  Find us at: http://www.xbian.org http://github.com/xbianonpi/xbian
##
##  This Program is free software; you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation; either version 2, or (at your option)
##  any later version.
##
##  This Program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with XBMC; see the file COPYING.  If not, see
##  <http://www.gnu.org/licenses/>.
##
##

use_debug=no

if [ -e $XBIANROOT/common.functions ]; then
    . $XBIANROOT/common.functions
else
    echo "Wrong setup. Open folder containing xbianonpi/xbian clone and rerun \"./run.me prepare\""
    exit 500
fi

do_wipe()
{
    dir="$1"
    [ ! -e "$dir/working/rootfs" ] || do_run rm -r "$dir/working/rootfs"
    rm -f "$dir/working/*"
}

do_img()
{
    dir=$(readlink -f "$1")
    do_wipe "$dir"
    if grep -q centos /etc/os-release; then
        yum -y install $config_yum_base 2>/dev/null 1>/dev/null
    else
        apt-get install -y --force-yes -o Acquire::Languages=none -o APT::Install-Suggests=0 -o APT::Install-Recommends=0 $config_deb_base 1>/dev/null
    fi

    mkdir -p "$dir/working"
    cd "$dir/working"

    rm -fr $IMGNAME; sync; touch $IMGNAME
    #convert size to byte size
    config_img_size=$(echo $config_img_size | sed "s%G% \*1024M%;s%M% \*1024K%;s%K% \*1024%;" | bc)

    [ $config_fstype_root = btrfs ] && [ $config_img_size -lt 1200000000 ] && config_img_size=1200000000
    truncate -s $config_img_size $IMGNAME

    modprobe -q loop
    parted -s $IMGNAME mklabel msdos

    if [ -z $config_offset_root ]; then
        config_offset_root=141312;
    fi
    if [ -z $config_fstype_boot ]; then
#        echo "71680,+,83,," | sfdisk -u S -N1 -H 4 -S 16 -q $IMGNAME > /dev/null 2>&1
        echo "$config_offset_root,+,83,," | sfdisk -u S -N1 -H 4 -S 16 -q $IMGNAME > /dev/null 2>&1
    else
        echo "2048,69632,b,*," | sfdisk -u S -N1 -H 4 -S 16 -q $IMGNAME > /dev/null 2>&1
#        echo "71680,+,83,," | sfdisk -u S -N2 -H 4 -S 16 -q $IMGNAME > /dev/null 2>&1
        echo "$config_offset_root,+,83,," | sfdisk -u S -N2 -H 4 -S 16 -q $IMGNAME > /dev/null 2>&1
    fi
    loopd=$(kpartx -s -l $IMGNAME -av | tail -1 | awk '{print $3}'); loopd=${loopd%%p?}; echo loopd=$loopd > /run/$IMGNAME.loopd
    if [ -z $config_fstype_boot ]; then
        rootpart=1
    else
        rootpart=2
    	case $config_fstype_boot in
	    ext2)
                mkfs.ext2 -L xbianboot /dev/mapper/${loopd}p1 2>/dev/null 1>&2
                ;;
            vfat|fat|msdos)
                mkfs.msdos -F 16 -n xbianboot /dev/mapper/${loopd}p1 2>/dev/null 1>&2
                ;;
        esac
    fi

    case $config_fstype_root in
        ext4|ext2|ext3)
            mkfs.$config_fstype_root -L $config_rootfs_label /dev/mapper/${loopd}p${rootpart} 2>/dev/null 1>&2
            ;;
        btrfs)
            if mkfs.btrfs --help 2>&1 | grep -q '\-O'; then
                mkfs.btrfs -O skinny-metadata -m single -d single -n 16384 -L $config_rootfs_label /dev/mapper/${loopd}p${rootpart} 2>&1
            else
                mkfs.btrfs -m single -d single -n 16384 -L $config_rootfs_label /dev/mapper/${loopd}p${rootpart} 2>&1
            fi
            ;;
    esac

#    if [ -n "$config_build_targets" ]; then
#        for t in $config_build_targets; do
#            ( rexp ../env; do_run $config_build_env $config_build_make $t; )
#        done
#    else
#        ( rexp ../env; do_run $config_build_env $config_build_make; )
#    fi

}

do_debootstrap()
{
    dir=$(readlink -f "$1")
    cd "$dir/working"

    if [ -e /run/$IMGNAME.loopd ]; then
        . /run/$IMGNAME.loopd
        export loopd
    else
        do_exit "missing loop/img/other error" 100
    fi

    mkdir -p ./rootfs
    if [ -z $config_fstype_boot ]; then
        rootpart=1
    else
        rootpart=2
    fi
    mount -t $config_fstype_root $config_fsoptions_root /dev/mapper/${loopd}p${rootpart} ./rootfs
    case $config_fstype_root in
        btrfs)
            btrfs sub create ./rootfs/root
            btrfs sub create ./rootfs/root/@
            btrfs sub create ./rootfs/modules
            btrfs sub create ./rootfs/modules/@
            btrfs sub create ./rootfs/home
            btrfs sub create ./rootfs/home/@
            ;;
        *)
            ;;
    esac
    umount ./rootfs

    [ -z "$config_fsoptions_root" ] && [ "$config_fstype_root" = btrfs ] && config_fsoptions_root='-o '

    case $config_fstype_root in
        btrfs)
            mount -t $config_fstype_root $config_fsoptions_root,subvol=root/@ /dev/mapper/${loopd}p${rootpart} ./rootfs
            mkdir ./rootfs/home; mkdir -p ./rootfs/lib/modules
            mount -t $config_fstype_root $config_fsoptions_root,subvol=home/@ /dev/mapper/${loopd}p${rootpart} ./rootfs/home
            mount -t $config_fstype_root $config_fsoptions_root,subvol=modules/@ /dev/mapper/${loopd}p${rootpart} ./rootfs/lib/modules
            ;;
        *)
            mount -t $config_fstype_root $config_fsoptions_root /dev/mapper/${loopd}p${rootpart} ./rootfs
            ;;
    esac

    mkdir -p ./rootfs/tmp/tmp && mount -o bind /tmp ./rootfs/tmp/tmp; mkdir -p ./rootfs/var/cache/apt/archives && mount -o bind /tmp ./rootfs/var/cache/apt/archives

    find ./rootfs/tmp -iname \*.deb | xargs rm -f

    mkdir -p ./rootfs/boot
    if ! [ -z $config_fstype_boot ]; then
        mount -t $config_fstype_boot /dev/mapper/${loopd}p1 ./rootfs/boot
    fi

    [ -n "$config_distro_variant" ] && export config_distro_variant="--variant=$config_distro_variant"
    [ -n "$config_include_deb" ] && export config_include_deb="--include=$config_include_deb"
    [ -n "$config_exclude_deb" ] && export config_exclude_deb="--exclude=$config_exclude_deb"

    debootstrap --download-only $config_exclude_deb $config_distro_variant $config_include_deb --no-check-gpg --arch $config_distro_arch --foreign $config_distro_name ./rootfs $config_distro_url

    if grep -q centos /etc/os-release; then
        [ -d qemu ] && rm -rf qemu
        mkdir qemu; cd qemu
        wget -q http://security.ubuntu.com/ubuntu/pool/universe/q/qemu/qemu-user-static_2.0.0+dfsg-2ubuntu1.9_amd64.deb
        ar -x *.deb
        tar -xf data.tar.*
        mkdir -p ../rootfs/usr/bin; cp usr/bin/qemu-arm-static ../rootfs/usr/bin/qemu-arm-static
        cd ..
        rm -rf qemu
    else
        mkdir -p ./rootfs/usr/bin; cp /usr/bin/qemu-arm-static ./rootfs/usr/bin
    fi

    #### hack to remove packages which raspbian considers essential and doesn't want them remove even when excluded and 
    #### another package with it's function is going to be installed (eg sysvinit vs. upstart)
    sed -i 's/sysvinit //' ./rootfs/debootstrap/required; sed -i '/sysvinit /d' ./rootfs/debootstrap/debpaths
    sed -i 's/sysvinit-core//' ./rootfs/debootstrap/required; sed -i '/sysvinit-core/d' ./rootfs/debootstrap/debpaths
    sed -i 's/systemd-sysv//' ./rootfs/debootstrap/required; sed -i '/systemd-sysv/d' ./rootfs/debootstrap/debpaths

    #### On CentOS the binfmt_misc entry for qemu-arm points
    #### to /usr/bin/qemu-arm instead of /usr/bin/qemu-arm-static
    #### This works cross-platform
    [ -f /proc/sys/fs/binfmt_misc/qemu-arm ] && echo "-1" >/proc/sys/fs/binfmt_misc/qemu-arm 2>/dev/null 1>/dev/null || :
    if ! grep -q /usr/bin/qemu-arm-static /proc/sys/fs/binfmt_misc/qemu-arm; then
        echo ':qemu-arm:M::\x7fELF\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x28\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:/usr/bin/qemu-arm-static:' > /proc/sys/fs/binfmt_misc/register || : 
    fi

    chroot ./rootfs debootstrap/debootstrap --second-stage

    echo "deb $config_distro_url $config_distro_name main" >> ./rootfs/etc/apt/sources.list
}

do_xbian()
{
    dir=$(readlink -f "$1")

    do_hooks pre-xbiandebs.d

    cd "$dir/working"

    chroot ./rootfs apt-get update
    chroot ./rootfs wget $config_xbianrepository
    chroot ./rootfs dpkg -i --force-confdef --force-confnew $(basename $config_xbianrepository)
    chroot ./rootfs rm -f $(basename $config_xbianrepository)

    chroot ./rootfs sed -i 's/### //g' /etc/apt/sources.list.d/xbian.list; cp ./rootfs/etc/apt/sources.list.d/xbian.list /tmp/xbian.list

    [ "$config_allow_staging_devel" = yes ] || ( IFS=$'\n'; for l in $(grep devel /tmp/xbian.list); do sed -i "s%$l%###\ $l%" /tmp/xbian.list; done; )
    [ "$config_allow_staging" = yes ] || ( IFS=$'\n'; for l in $(grep staging /tmp/xbian.list); do sed -i "s%$l%###\ $l%" /tmp/xbian.list; done; )
    cp /tmp/xbian.list ./rootfs/etc/apt/sources.list.d/xbian.list

    chroot ./rootfs apt-get update

    export DEBIAN_FRONTEND=noninteractive

    mkdir -p ./rootfs/fake
    ( cd ./rootfs/fake
    for f in initctl invoke-rc.d restart start stop start-stop-daemon service reboot; do
        rm -f ./$f && ln -s /bin/true ./$f
    done )

    export PATH=/fake:$PATH

    ### let's settle down apt consistency after debootstrap (without initial install -f will not install
    ### any packages in next loop even with correct dependencies
    eval LC_ALL=C chroot ./rootfs apt-get install -y --force-yes -f
    eval LC_ALL=C chroot ./rootfs apt-get install -y --force-yes -o Acquire::Languages=none -o APT::Install-Suggests=0 -o APT::Install-Recommends=0 -o Dir::Cache=/tmp/tmp -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" $config_xbian_deb 2>&1 | grep --line-buffer -v 'Can not write log, openpty()\|/proc/mounts\|/com/ubuntu/upstart\|/var/run/dbus/system_bus_socket'

    ### make pin settings effective
    eval LC_ALL=C chroot ./rootfs apt-get upgrade -y --force-yes
    rm -fr ./rootfs/fake
}

clean_tmp()
{
    set +e

    umfail=1
    while [ $umfail -eq 1 ]; do
        umfail=0
        for d in rootfs/var/cache/apt/archives rootfs/tmp/tmp; do
            if mountpoint -q $XBIANARCHDIR/working/$d; then
                umount $XBIANARCHDIR/working/$d || umfail=1
            fi
        done
        [ $umfail -eq 0 ] || sleep 5
    done

    set -e
    return 0
}

clean_all()
{
    set +e

    for d in $(mount | grep "mapper/$loopd\|$dir/working/rootfs" | awk '$5 ~ /btrfs/ {print $3}' 2>/dev/null); do
        mountpoint -q $d && btrfs fi sync $d >/dev/null 2>&1
    done

    umfail=1
    while [ $umfail -eq 1 ]; do
        umfail=0
        for d in $(mount | grep "mapper/$loopd\|$dir/working/rootfs" | awk '{print $3}' | sort -r); do
            if [ $(mountpoint -q $d; echo $?) -eq 0 ] && [ "$d" != "/" ]; then
                umount $d || umfail=1
            fi
        done
        [ $umfail -eq 0 ] || sleep 5
    done

    set -e
    return 0
}

clean_loopd()
{
    set +e

    cd $XBIANARCHDIR/working
    kpartx -dv $IMGNAME >/dev/null 2>&1
    rm -f /run/$IMGNAME.loopd

    set -e
    return 0
}

do_finish()
{
    dir=$(readlink -f "$1")

    if [ -e /run/$IMGNAME.loopd ]; then
        . /run/$IMGNAME.loopd
        export loopd
    fi

    cd "$dir/../.."

    do_hooks pre-finish.d

    clean_tmp
    chroot "$dir/working/rootfs" /usr/local/sbin/all-clean >/dev/null 2>&1 || :

    cd "$dir/working"

    rm rootfs/usr/bin/qemu-arm-static

    df -h | grep /working/

    clean_all

    clean_loopd
}

do_post()
{
    export config_img_size=$(echo $config_img_size | sed "s%G% \*1024M%;s%M% \*1024K%;s%K% \*1024%;" | bc)
    dir=$(readlink -f "$1")
    mkdir -p "$dir/working/rootfs"

    do_hooks post-img.d

    if [ -n "$config_img_compress" ]; then
        echo "compressing $IMGNAME. this may take a while."
        do_run $config_img_compress "$dir/working/$IMGNAME"
    fi
    mv "$dir"/working/$IMGNAME* "$dir"
}

# ----------------------

[ $(id -u) -ne 0 ] && do_exit "for img creation please run again with root privileges"

GETOPT=$(getopt \
        --longoptions=action:,arch:,config_source_refresh:,help,list,debug \
        --options=a:m:hld \
        -- "$@" ) \
        || exit 128

export XBIANPKGDIR="$(pwd)"
if [ -e $XBIANPKGDIR/build.~lock ]; then
    echo "another process running... or stale lock exists at $XBIANPKGDIR/build.~lock"
    exit 100
fi

for dir in $(find build/ -mindepth 1 -maxdepth 1 -type d | sort); do
    export XBIANARCHDIR=$(readlink -f "$dir")

    unset $(env | grep config_ | awk -F'=' '{print $1}')
    result=0

    [ -e build/config ] && rexp build/config
    [ -e "$dir/config" ] && rexp "$dir/config"

    eval set -- ${GETOPT}

    while [ "$#" -gt '0' ]; do
        case "$1" in
            (-l|--list)
                printf "Local Name: %s\n" "${dir#*build/}"
                continue 2
                ;;
            (--action|-a)
                opt_action=$2
                shift 2
                ;;
            (--arch|-m)
                opt_arch=$2
                shift 2
                ;;
            (--config_*)
                param=$1
                param="${param##--}=$2"
                do_run export $param
                shift 2
                ;;
            (--help|-h)
                do_show_help
                exit 0
                ;;
            (--debug|-d)
                use_debug=yes
                shift
                ;;
            *)
                shift 1
                ;;
        esac
    done

    [ $use_debug = no ] || set -x

    [ -n "$opt_arch" -a "$opt_arch" != $(basename "$dir") ] && continue
    [ -z "$opt_arch" ] && opt_arch=$(basename "$dir")

    export config_platform=${opt_arch%%-*}
    export config_platform_branch=$opt_arch
    export config_branch=${opt_arch##*-}

    export IMGNAME=$config_img_name-$(basename $dir)-$(date +%Y%m%d).img

    touch $XBIANPKGDIR/build.~lock
    trap "clean_tmp; clean_all; clean_loopd; rm -f $XBIANPKGDIR/build.~lock" EXIT TERM

    case $opt_action in
        img)
            ( do_img "$dir" )
            ;;
        debootstrap)
            ( do_debootstrap "$dir" )
            ;;
        xbian)
            ( do_xbian "$dir" )
            ;;
        finish)
            ( do_finish "$dir" )
            ;;
        post)
            ( do_post "$dir" )
            ;;
        ""|build)
            dr=$(pwd)
            for act in do_img do_debootstrap do_xbian do_finish do_post; do
                ( $act "$dir" )
            done
            ;;
        *)
            ;;
    esac
done

printf "\n-------------------------------\nFINISHED OK\n-------------------------------\n"
